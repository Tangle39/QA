## Q:linux开机过程？  
1. 加载BIOS（Basic Input Output System）  
2. 读取MBR（Main Boot Record）  
3. Boot Load  
4. 加载内核  
5. 用户层init依据inittab文件来设定运行等级  
6. init进程执行rc.sysinit  
7. 启动内核模块  
8. 执行不同运行级别的脚本程序  
9. 执行/etc/rc.d/rc.local  
10. 执行/bin/login程序，进入登录状态

## vi  
: wq (输入「wq」，存盘并退出vi)--末行模式；=在命令模式下执行ZZ  
: q! (输入q!， 不存盘强制退出vi)  
按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；  
「dd」：删除光标所在行。  ndd：删除n行  
gg:到第一行
查找关键词
:/[pattern]  n向前N向后，但是mac其实自带了查找
## 定时任务  

<table>
        <tr>
            <th>0</th>
            <th>12</th>
            <th>*</th>
            <th>*</th>
            <th>*</th>
            <th>mail dmtsai -s "at 12:00" < /home/dmtsai/.bashrc</th>
        </tr>
        <tr>
            <th>分</th>
            <th>时</th>
            <th>日</th>
            <th>月</th>
            <th>周</th>
            <th>《==============命令行=======================》</th>
        </tr>
    </table>   

## 写了shell，怎么运行? 几种方法:  

1. 加执行权限：`chmod +x echo.sh`  
然后：在目录下`./ echo.sh`,也可以绝对路径`/.../.../echo.sh`    

2. 调用解释器使得脚本执行：`bash echo.sh`，或者`sh ./**.sh`  

## rsync  
rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。

## 后台执行命令
为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用  
* &
在命令后面加上& 实现后台运行。例如：sh test.sh &  
* nohup
使用&命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。  
所以使用：  
nohup command &  
在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中,除非另外指定输出  
nohup command > myout.file 2>&1 &
* 2>&1
1 一般代表的就是STDOUT_FILENO,2表示错误输出 ,这个写法将错误信息和输出均写到file里

## 更改文件权限
chmod [] <file>
查看文件权限： ls -l
d指目录， rw-r--r--   = 644
## case  

1. 当前文件夹及子目录中找出内容含“Ex”的文件并按文件大小排序。  
ls -S \`grep -Rl Ex ./* \`  
\# -S从大到小 ; grep：-R搜寻子目录，-l只显示文件名 ;  利用\` \`将其作为ls的输入  ; 少\*会多一个/  
grep -n:结果输出行号

2. 11分钟后关机  
`shutdown -h +11`  

3. 更改Linux系统的主机名(hostname)  
`sudo vi /etc/hostname`  
4. 显示当前目录下的所有文件及文件夹包括隐藏的.和..等的详细信息  
`ls -al`  
5. arp(Address Resolution Protocol)  
arp命令用于操作主机的arp缓冲区，可以用来显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的ip地址与MAC地址对应关系。  
查看ARP缓存记录的命令  
`arp -a`  
6. 重新启动Linux系统的同时把内存中的信息写入硬盘  
shutdown -r now  
shutdown命令可以**安全地**关闭或重启Linux系统  
使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的**丢失**。所以使用reboot命令的场合主要是在**单用户**模式。  
7. 切换目录  
home:cd ~  
根目录:cd /  
8. 帮助类命令  
ls --help  
man ls(更详细)  
9. 重定向 将当前目录的文件存至某一路径：  
ls >> /Users/lu/Documents/Code/linux/test.txt(>为覆盖；>>追加)  
10. 列出当前目录以及子目录下所有扩展名为“.txt”的文件  
find . -name "\*.txt"  
11. 利用管道符计算1+2+3+...+100的值  
echo {1..100} |tr ' ' '+'| bc   
\# tr:替换，   bc：linux计算器  


## 0830
### ls
ls >c 会**先**生成c文件

## 进程vs线程  
进程是操作系统**资源分配**的基本单位；线程是**任务调度和执行**的基本单位  
在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行**栈**（没有堆）和程序计数器（PC），线程之间切换的开销小。  
所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）  
内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。  
包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

* 普通整数的一般赋值、增量和减量语句会产生多条机器指令，操作均不具有原子性，需要同步
* 扩展交换空间
 /dev/zero Linux虚拟设备 “零”设备，可以无限的提供空字符

 * 线程由操作系统控制，
协程由程序自身控制

0901
* top
显示当前系统资源使用情况，相当于任务管理器

* 通信
1. 进程通信： 
每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。
2. 线程通信
由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。  
3. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)  
Linux线程间通信：互斥量（mutex），信号量，条件变量

* ls -lh查看文件列表，含详细信息和大小（h为方便阅读显示，-human-readable）

* df
检查linux服务器的文件系统的磁盘空间占用情况

* du
显示每个文件和目录的磁盘使用空间。

* 先排序，后去重(因为 uniq 只能处理邻接的行)
sort demo.txt|uniq

* uptime
打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的**1分钟、5分钟和15分钟**内的平均负载。

* who 
查看登陆者信息，如果在自己mac查看，至少有console和tty

>reference  
http://ju.outofmemory.cn/entry/337199  
https://www.cnblogs.com/shishanyu/p/7966975.html
