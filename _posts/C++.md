[TOC]

# 编译

`g++ soure.cpp`

# 打印变量类型

``````c++
#include <typeinfo> 
#include <iostream>
cout << typeid(a).name() << endl;
``````

# 面向对象的三个基本特征

* 封装
* 继承
* 多态

## 继承

继承允许依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。已有的类称为**基类**，新建的类称为**派生类**。形式如下：

```c++
class derived-class: access-specifier base-class
```

## 多态

当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

### 虚函数

可以在基类中将被重写的成员函数设置为虚函数，其含义是：当通过基类的指针或者引用调用该成员函数时，将根据__指针指向的对象类型__确定调用的函数，而非指针的类型

**虚函数的作用：简单讲即实现多态。**  

  基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做迟绑定。

**1.每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual table，vtbl）。**

  **2.每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。**

**特别的**：

　　（1）当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果；

　　（2）内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；

　　（3）构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数；

　　（4）静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。

### 纯虚函数

想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

`virtual int area() = 0;`

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。

包含纯虚函数的类是**抽象类**，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

### 多继承

类可以从多个类继承成员，语法如下：

```c++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

# 类

## 类的静态成员

静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义(使用范围解析运算符 **::** )就会报错，初始化是赋一个初始值，而定义是分配内存。优先级似乎比private更高

### 静态成员函数

静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针

## this 指针

每一个对象都能通过 **this** 指针来访问自己的地址。**this** 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

## 类访问修饰符

关键字 **public、private、protected** 称为访问修饰符，成员和类的_默认_访问修饰符是 `private`。

在类里面不写是什么类型，默认是 **private** 的。

**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

**protected（受保护）**成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

## 构造函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

### 使用初始化列表来初始化字段

使用初始化列表来初始化字段：

``````c++
Line::Line( double len): length(len) 
{    
    cout << "Object is being created, length = " << len << endl; 
}
``````

## 析构函数

**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

## 拷贝构造函数

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它**必须**有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

``````c++
classname (const classname &obj) 
{   
  // 构造函数的主体 
}
``````

## 友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**

## 继承

```c++
class derived-class: access-specifier base-class
```

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承



# 动态内存

C++ 程序中的内存分为两个部分：

- **栈：**在函数内部声明的所有变量都将占用栈内存。
- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。

很多时候，无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。

如果不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。